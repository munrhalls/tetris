1. mentally map it out
2. translate thought process to comments
  markGroupedLines: function markGroupedLines(lines) {
    // sort
    // store list
    // line to line
    // store group
    // if current + 1 isn't out of list, run
    // search for current + 1
    // if current + 1 is there
    // if it is, push to group

    // if current - 1 isn't out of list, run
    // if not check current - 1
    // search for current - 1
    // if there, push to group 

    // if both current + 1, current - 1 aren't a list's line
    // if no group length
    // mark line's grouped property as 1
    // reset group store
    
    // if group length
    // iterate group
    // mark each group's line grouped property with group's length
    // reset group store
  },

3. write code
markGroupedLines: function markGroupedLines(lines) {
    lines.sort((a, b) => a.frozenRow > b.frozenRow);
    let groupsList = [];
    let group = [];
    for (let line of lines) {
      let isNextNeighbour;
      let isPrevNeighbour;

      isNextNeighbour = lines.find(
        (item) => item.frozenRow === line.frozenRow + 1
      );
      if (isNextNeighbour) {
        group.push(line);
        continue;
      }

      isPrevNeighbour = lines.find(
        (item) => item.frozenRow === line.frozenRow - 1
      );
      if (isPrevNeighbour) {
        group.push(line);
        continue;
      }

      if (group.length) {
        for (let item of group) {
          item.grouped = group.length;
        }
        groupsList.push(group);
        group = [];
      }
      if (!group.length) line.grouped = 1;
    }
    console.log(groupsList);
    console.log(lines);
  },

  4. test if it works as it should in all cases, from extremes/edges to random normal cases

In practice, just a few mock up's, try to be a user who finds ways to make the code fail: 

  setTimeout(() => {
  let mockxyGroup = [];
  for (let i = 0; i < 22; i++) {
    mockxyGroup.push([20, i]);
    mockxyGroup.push([21, i]);
    mockxyGroup.push([22, i]);

    mockxyGroup.push([24, i]);
  }
  for (let i = 5; i < 16; i++) {
    mockxyGroup.push([17, i]);
  }
  tetroFreezer.freezeTetro(mockxyGroup);
}, 300);
