1. mentally map it out
2. translate thought process to comments
  markGroupedLines: function markGroupedLines(lines) {
    // sort
    // store list
    // line to line
    // store group
    // if current + 1 isn't out of list, run
    // search for current + 1
    // if current + 1 is there
    // if it is, push to group

    // if current - 1 isn't out of list, run
    // if not check current - 1
    // search for current - 1
    // if there, push to group 

    // if both current + 1, current - 1 aren't a list's line
    // if no group length
    // mark line's grouped property as 1
    // reset group store
    
    // if group length
    // iterate group
    // mark each group's line grouped property with group's length
    // reset group store
  },

3. write code
markGroupedLines: function markGroupedLines(lines) {
    lines.sort((a, b) => a.frozenRow > b.frozenRow);
    let groupsList = [];
    let group = [];
    for (let line of lines) {
      let isNextNeighbour;
      let isPrevNeighbour;

      isNextNeighbour = lines.find(
        (item) => item.frozenRow === line.frozenRow + 1
      );
      if (isNextNeighbour) {
        group.push(line);
        continue;
      }

      isPrevNeighbour = lines.find(
        (item) => item.frozenRow === line.frozenRow - 1
      );
      if (isPrevNeighbour) {
        group.push(line);
        continue;
      }

      if (group.length) {
        for (let item of group) {
          item.grouped = group.length;
        }
        groupsList.push(group);
        group = [];
      }
      if (!group.length) line.grouped = 1;
    }
    console.log(groupsList);
    console.log(lines);
  },

  4. test if it works as it should in all cases, from extremes/edges to random normal cases

In practice, just a few mock up's, try to be a user who finds ways to make the code fail: 

  setTimeout(() => {
  let mockxyGroup = [];
  for (let i = 0; i < 22; i++) {
    mockxyGroup.push([20, i]);
    mockxyGroup.push([21, i]);
    mockxyGroup.push([22, i]);

    mockxyGroup.push([24, i]);
  }
  for (let i = 5; i < 16; i++) {
    mockxyGroup.push([17, i]);
  }
  tetroFreezer.freezeTetro(mockxyGroup);
}, 300);


////////////////////////////////////////////////////////////////////
// big re-configuration
// 1. think it out
// 2. translate to comments
    // tetris is re-configured
    // building
    //-makeBoard
    //-makeNewTetro

    // displaying
    //-frameAnimator
    //-painter

    // processing
    //-centralFrameProcessor

    // moving
    //-all movers

    // freezing

    // game managing
    //-runner
    //-scorer


    // get cell painter

    // when a line clear is achieved, it's composed of multiple tetroes
    // cells are part of 1 line clear but of multiple tetroes

    // first frozenTetroes update equuals to:
    // all linesToClear are looped, one by one
    // all tetroes are looped one by one
    // all cells from a tetro equal to cells filter looped one by one
    // every cell is compared for intersection with line clear
    // if cell is not part of line clear, move on
    // if cell is part of line clear
    // it's filtered out of tetro
    // it undergoes unpaintCell by cell painter

    //and then every cell looped again
    //. chain after filter
    // adjusted after clear cells
    // every cell is compared to being above line clear (smaller or equal to)
    // if not smaller or equal to, move on
    // if smaller or equal to, unpaint cell
    // move y down by 1 (make bigger by 1)
    // paint cell

    // after all that looping is complete
    // all frozenTetroes cells that were part of line clears are cleared from tetroes
    // all above line clear, each time, unpainted
    // properly moved south by line clear (1)
    // painted after that

    // return frozenTetroesAfterLineClears
    // tetroFreezer updates frozen tetroes with frozenTetroesAfterLineClears
  // 3. code it

